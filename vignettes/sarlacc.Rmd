---
title: "Error correction of long ONT reads with UMIs"
author: "Florian Bieberich and Aaron Lun"
package: sarlacc
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Error correction of long ONT reads with UMIs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---


```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
```

```{r setup, echo=FALSE, message=FALSE}
library(sarlacc)
```

# Introduction

The `r Biocpkg("sarlacc")` package is designed to perform error correction on long reads such as those generated with the Oxford Nanpore Technology (ONT).
This is done by considering the unique molecular identifier (UMI) associated with each read.
Reads with the same UMI are groups together and used to construct a consensus sequence, thereby correcting for any sequencing errors unique to each read.
In this manner, we can overcome the higher error rate of ONT data while still retaining the long-read capabilities.

# Setting up some sequence data

To demonstrate the various `r Biocpkg("sarlacc")` functions in this vignette, we will mock up some data and save it as a FASTQ file.
Needless to say, this is not necessary for users with sequencing data from real experiments.

```{r}
source(system.file("scripts", "create_mock_seqs.R", package="sarlacc"))
fastq
```

We load in the sequences using `r Biocpkg("Biostrings")` to create a `QualityScaledDNAStringSet`.

```{r}
input <- readQualityScaledDNAStringSet(fastq)
input
```

Note that if quality information is not available, a `DNAStringSet` will suffice as input to `r Biocpkg("sarlacc")` functions.

# Aligning adaptors

## Identifying alignment parameters

Our first task is to align the adaptors to the end of the reads.
For this mock data set, we have the following adaptor sequences:

```{r}
adaptor1
adaptor2
```

We determine suitable alignment parameters using the `tuneAlignment` function.
This will identify the parameter combination that maximizes the separation between the real alignment scores and those for scrambled input sequences^[Note that, for quality-based alignments, `match` and `mismatch` are not used.].

```{r}
tuning <- tuneAlignment(adaptor1, adaptor2, input)
tuning$parameters
```

We confirm that these values are sensible by examining the distribution of scores for the real alignments compared to the scrambled sequences.

```{r, fig.cap="Distribution of adaptor alignment scores for the real reads (blue) and scrambled sequences (red) using the tuned alignment parameters. Scores for both adaptors in the optimal orientation are added together to give the combined score for each read."}
real.dist <- density(tuning$scores$reads)
scram.dist <- density(tuning$scores$scrambled)
plot(real.dist, xlim=range(real.dist$x, scram.dist$x),
    ylim=range(real.dist$y, scram.dist$y), col="blue")
lines(scram.dist, col="red")
```

## Performing the alignment

We now align the adaptor sequences to all of the reads using the `adaptorAlign` function^[We are using fixed parameters chosen from one run of the `tuneAlignment`. We could also supply the tuned parameters directly but these may vary from run to run.].
For speed, the alignment will only consider the 250 bp on either end of the read, under the assumption that the adaptors should occur at the read ends.
This can be further sped up by distributing jobs across multiple cores with the `BPPARAM=` argument.

```{r}
aln.out <- adaptorAlign(adaptor1, adaptor2, input, gapOpening=4, gapExtension=1)
colnames(aln.out)
```

The output is a `DataFrame` that contains alignment information for each adaptor.
For example, the `adaptor1` field contains a nested `DataFrame` with alignment scores and positions for `adaptor1` on the read:

```{r}
aln.out$adaptor1
```

Note that the positions refer to coordinates on the `aln.out$reads`.
These may be different from `input` as the output `reads` will be reverse-complemented (if necessary) to ensure that adaptor 1 and 2 are located on the 5' and 3' ends respectively. 
Whether or not a read sequence was reverse-complemented is indicataed by the `aln.out$reversed` field:

```{r}
summary(aln.out$reversed)
```

# Removing adaptors

We use the `getScoreThreshold` function to choose an appropriate score threshold for the presence of an adaptor.

```{r}
thresh <- getScoreThresholds(aln.out)
thresh$threshold1
thresh$threshold2
```

We verify that the thresholds are suitable for adaptor 1:

```{r, fig.cap="Distribution of adaptor 1 alignment scores for the real reads (blue) and scrambled sequences (red)."}
real.dist <- density(thresh$scores1$reads)
scram.dist <- density(thresh$scores1$scrambled)
plot(real.dist, xlim=range(real.dist$x, scram.dist$x),
    ylim=range(real.dist$y, scram.dist$y), col="blue")
lines(scram.dist, col="red")
abline(v=thresh$threshold1, col="grey", lty=2)
```

... and for adaptor 2:

```{r, fig.cap="Distribution of adaptor 2 alignment scores for the real reads (blue) and scrambled sequences (red)."}
real.dist <- density(thresh$scores2$reads)
scram.dist <- density(thresh$scores2$scrambled)
plot(real.dist, xlim=range(real.dist$x, scram.dist$x),
    ylim=range(real.dist$y, scram.dist$y), col="blue")
lines(scram.dist, col="red")
abline(v=thresh$threshold2, col="grey", lty=2)
```

We use the `chopReads` function to filter only those reads that have adaptors on both sides^[We'll round the thresholds to fixed values, for simplicity and to simplify reproducibility.].
This yields a new `DataFrame` with fewer reads and sequences in `reads` where the adaptors have been removed.
One can use these sequences directly for downstream analyses if error correction is not necessary. 

```{r}
chopped <- chopReads(aln.out, 11, 11)
chopped$reads
```

# Performing error correction

## Extracting the UMIs

We use the `umiExtract` function to extract the UMI sequence for each adaptor alignment.
By default, it will guess the UMI position from the location of `N`s in the `adaptor1` sequence, but this can also be manually specified if the adaptor sequence is complex.

```{r}
umis <- umiExtract(aln.out$adaptor1) 
umis
```


# Grouping the reads



# Session information

```{r}
sessionInfo()
```
